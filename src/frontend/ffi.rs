/* automatically generated by rust-bindgen */

pub const __BITS_PER_LONG: ::std::os::raw::c_uint = 64;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const DTV_UNDEFINED: ::std::os::raw::c_uint = 0;
pub const DTV_TUNE: ::std::os::raw::c_uint = 1;
pub const DTV_CLEAR: ::std::os::raw::c_uint = 2;
pub const DTV_FREQUENCY: ::std::os::raw::c_uint = 3;
pub const DTV_MODULATION: ::std::os::raw::c_uint = 4;
pub const DTV_BANDWIDTH_HZ: ::std::os::raw::c_uint = 5;
pub const DTV_INVERSION: ::std::os::raw::c_uint = 6;
pub const DTV_DISEQC_MASTER: ::std::os::raw::c_uint = 7;
pub const DTV_SYMBOL_RATE: ::std::os::raw::c_uint = 8;
pub const DTV_INNER_FEC: ::std::os::raw::c_uint = 9;
pub const DTV_VOLTAGE: ::std::os::raw::c_uint = 10;
pub const DTV_TONE: ::std::os::raw::c_uint = 11;
pub const DTV_PILOT: ::std::os::raw::c_uint = 12;
pub const DTV_ROLLOFF: ::std::os::raw::c_uint = 13;
pub const DTV_DISEQC_SLAVE_REPLY: ::std::os::raw::c_uint = 14;
pub const DTV_FE_CAPABILITY_COUNT: ::std::os::raw::c_uint = 15;
pub const DTV_FE_CAPABILITY: ::std::os::raw::c_uint = 16;
pub const DTV_DELIVERY_SYSTEM: ::std::os::raw::c_uint = 17;
pub const DTV_ISDBT_PARTIAL_RECEPTION: ::std::os::raw::c_uint = 18;
pub const DTV_ISDBT_SOUND_BROADCASTING: ::std::os::raw::c_uint = 19;
pub const DTV_ISDBT_SB_SUBCHANNEL_ID: ::std::os::raw::c_uint = 20;
pub const DTV_ISDBT_SB_SEGMENT_IDX: ::std::os::raw::c_uint = 21;
pub const DTV_ISDBT_SB_SEGMENT_COUNT: ::std::os::raw::c_uint = 22;
pub const DTV_ISDBT_LAYERA_FEC: ::std::os::raw::c_uint = 23;
pub const DTV_ISDBT_LAYERA_MODULATION: ::std::os::raw::c_uint = 24;
pub const DTV_ISDBT_LAYERA_SEGMENT_COUNT: ::std::os::raw::c_uint = 25;
pub const DTV_ISDBT_LAYERA_TIME_INTERLEAVING: ::std::os::raw::c_uint = 26;
pub const DTV_ISDBT_LAYERB_FEC: ::std::os::raw::c_uint = 27;
pub const DTV_ISDBT_LAYERB_MODULATION: ::std::os::raw::c_uint = 28;
pub const DTV_ISDBT_LAYERB_SEGMENT_COUNT: ::std::os::raw::c_uint = 29;
pub const DTV_ISDBT_LAYERB_TIME_INTERLEAVING: ::std::os::raw::c_uint = 30;
pub const DTV_ISDBT_LAYERC_FEC: ::std::os::raw::c_uint = 31;
pub const DTV_ISDBT_LAYERC_MODULATION: ::std::os::raw::c_uint = 32;
pub const DTV_ISDBT_LAYERC_SEGMENT_COUNT: ::std::os::raw::c_uint = 33;
pub const DTV_ISDBT_LAYERC_TIME_INTERLEAVING: ::std::os::raw::c_uint = 34;
pub const DTV_API_VERSION: ::std::os::raw::c_uint = 35;
pub const DTV_CODE_RATE_HP: ::std::os::raw::c_uint = 36;
pub const DTV_CODE_RATE_LP: ::std::os::raw::c_uint = 37;
pub const DTV_GUARD_INTERVAL: ::std::os::raw::c_uint = 38;
pub const DTV_TRANSMISSION_MODE: ::std::os::raw::c_uint = 39;
pub const DTV_HIERARCHY: ::std::os::raw::c_uint = 40;
pub const DTV_ISDBT_LAYER_ENABLED: ::std::os::raw::c_uint = 41;
pub const DTV_STREAM_ID: ::std::os::raw::c_uint = 42;
pub const DTV_ISDBS_TS_ID_LEGACY: ::std::os::raw::c_uint = 42;
pub const DTV_DVBT2_PLP_ID_LEGACY: ::std::os::raw::c_uint = 43;
pub const DTV_ENUM_DELSYS: ::std::os::raw::c_uint = 44;
pub const DTV_ATSCMH_FIC_VER: ::std::os::raw::c_uint = 45;
pub const DTV_ATSCMH_PARADE_ID: ::std::os::raw::c_uint = 46;
pub const DTV_ATSCMH_NOG: ::std::os::raw::c_uint = 47;
pub const DTV_ATSCMH_TNOG: ::std::os::raw::c_uint = 48;
pub const DTV_ATSCMH_SGN: ::std::os::raw::c_uint = 49;
pub const DTV_ATSCMH_PRC: ::std::os::raw::c_uint = 50;
pub const DTV_ATSCMH_RS_FRAME_MODE: ::std::os::raw::c_uint = 51;
pub const DTV_ATSCMH_RS_FRAME_ENSEMBLE: ::std::os::raw::c_uint = 52;
pub const DTV_ATSCMH_RS_CODE_MODE_PRI: ::std::os::raw::c_uint = 53;
pub const DTV_ATSCMH_RS_CODE_MODE_SEC: ::std::os::raw::c_uint = 54;
pub const DTV_ATSCMH_SCCC_BLOCK_MODE: ::std::os::raw::c_uint = 55;
pub const DTV_ATSCMH_SCCC_CODE_MODE_A: ::std::os::raw::c_uint = 56;
pub const DTV_ATSCMH_SCCC_CODE_MODE_B: ::std::os::raw::c_uint = 57;
pub const DTV_ATSCMH_SCCC_CODE_MODE_C: ::std::os::raw::c_uint = 58;
pub const DTV_ATSCMH_SCCC_CODE_MODE_D: ::std::os::raw::c_uint = 59;
pub const DTV_INTERLEAVING: ::std::os::raw::c_uint = 60;
pub const DTV_LNA: ::std::os::raw::c_uint = 61;
pub const DTV_STAT_SIGNAL_STRENGTH: ::std::os::raw::c_uint = 62;
pub const DTV_STAT_CNR: ::std::os::raw::c_uint = 63;
pub const DTV_STAT_PRE_ERROR_BIT_COUNT: ::std::os::raw::c_uint = 64;
pub const DTV_STAT_PRE_TOTAL_BIT_COUNT: ::std::os::raw::c_uint = 65;
pub const DTV_STAT_POST_ERROR_BIT_COUNT: ::std::os::raw::c_uint = 66;
pub const DTV_STAT_POST_TOTAL_BIT_COUNT: ::std::os::raw::c_uint = 67;
pub const DTV_STAT_ERROR_BLOCK_COUNT: ::std::os::raw::c_uint = 68;
pub const DTV_STAT_TOTAL_BLOCK_COUNT: ::std::os::raw::c_uint = 69;
pub const DTV_MAX_COMMAND: ::std::os::raw::c_uint = 69;
pub const NO_STREAM_ID_FILTER: ::std::os::raw::c_int = -1;
pub const LNA_AUTO: ::std::os::raw::c_int = -1;
pub const MAX_DTV_STATS: ::std::os::raw::c_uint = 4;
pub const DTV_IOCTL_MAX_MSGS: ::std::os::raw::c_uint = 64;
pub const FE_TUNE_MODE_ONESHOT: ::std::os::raw::c_uint = 1;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(::std::mem::size_of::<__kernel_fd_set>() , 128usize , concat !
               ( "Size of: " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fd_set>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fd_set ) ) . fds_bits as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fd_set ) ,
                "::" , stringify ! ( fds_bits ) ));
}
impl Clone for __kernel_fd_set {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(::std::mem::size_of::<__kernel_fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__kernel_fsid_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( __kernel_fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __kernel_fsid_t ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __kernel_fsid_t ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for __kernel_fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub const FE_QPSK: fe_type = 0;
pub const FE_QAM: fe_type = 1;
pub const FE_OFDM: fe_type = 2;
pub const FE_ATSC: fe_type = 3;
pub type fe_type = ::std::os::raw::c_uint;
pub const FE_IS_STUPID: fe_caps = 0;
pub const FE_CAN_INVERSION_AUTO: fe_caps = 1;
pub const FE_CAN_FEC_1_2: fe_caps = 2;
pub const FE_CAN_FEC_2_3: fe_caps = 4;
pub const FE_CAN_FEC_3_4: fe_caps = 8;
pub const FE_CAN_FEC_4_5: fe_caps = 16;
pub const FE_CAN_FEC_5_6: fe_caps = 32;
pub const FE_CAN_FEC_6_7: fe_caps = 64;
pub const FE_CAN_FEC_7_8: fe_caps = 128;
pub const FE_CAN_FEC_8_9: fe_caps = 256;
pub const FE_CAN_FEC_AUTO: fe_caps = 512;
pub const FE_CAN_QPSK: fe_caps = 1024;
pub const FE_CAN_QAM_16: fe_caps = 2048;
pub const FE_CAN_QAM_32: fe_caps = 4096;
pub const FE_CAN_QAM_64: fe_caps = 8192;
pub const FE_CAN_QAM_128: fe_caps = 16384;
pub const FE_CAN_QAM_256: fe_caps = 32768;
pub const FE_CAN_QAM_AUTO: fe_caps = 65536;
pub const FE_CAN_TRANSMISSION_MODE_AUTO: fe_caps = 131072;
pub const FE_CAN_BANDWIDTH_AUTO: fe_caps = 262144;
pub const FE_CAN_GUARD_INTERVAL_AUTO: fe_caps = 524288;
pub const FE_CAN_HIERARCHY_AUTO: fe_caps = 1048576;
pub const FE_CAN_8VSB: fe_caps = 2097152;
pub const FE_CAN_16VSB: fe_caps = 4194304;
pub const FE_HAS_EXTENDED_CAPS: fe_caps = 8388608;
pub const FE_CAN_MULTISTREAM: fe_caps = 67108864;
pub const FE_CAN_TURBO_FEC: fe_caps = 134217728;
pub const FE_CAN_2G_MODULATION: fe_caps = 268435456;
pub const FE_NEEDS_BENDING: fe_caps = 536870912;
pub const FE_CAN_RECOVER: fe_caps = 1073741824;
pub const FE_CAN_MUTE_TS: fe_caps = 2147483648;
pub type fe_caps = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy)]
pub struct dvb_frontend_info {
    pub name: [::std::os::raw::c_char; 128usize],
    pub type_: fe_type,
    pub frequency_min: __u32,
    pub frequency_max: __u32,
    pub frequency_stepsize: __u32,
    pub frequency_tolerance: __u32,
    pub symbol_rate_min: __u32,
    pub symbol_rate_max: __u32,
    pub symbol_rate_tolerance: __u32,
    pub notifier_delay: __u32,
    pub caps: fe_caps,
}
#[test]
fn bindgen_test_layout_dvb_frontend_info() {
    assert_eq!(::std::mem::size_of::<dvb_frontend_info>() , 168usize , concat
               ! ( "Size of: " , stringify ! ( dvb_frontend_info ) ));
    assert_eq! (::std::mem::align_of::<dvb_frontend_info>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( dvb_frontend_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) . type_ as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) . frequency_min as
                * const _ as usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( frequency_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) . frequency_max as
                * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( frequency_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) .
                frequency_stepsize as * const _ as usize } , 140usize , concat
                ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( frequency_stepsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) .
                frequency_tolerance as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( frequency_tolerance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) . symbol_rate_min
                as * const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( symbol_rate_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) . symbol_rate_max
                as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( symbol_rate_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) .
                symbol_rate_tolerance as * const _ as usize } , 156usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( symbol_rate_tolerance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) . notifier_delay as
                * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( notifier_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_info ) ) . caps as * const _
                as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_info ) ,
                "::" , stringify ! ( caps ) ));
}
impl Clone for dvb_frontend_info {
    fn clone(&self) -> Self { *self }
}
impl Default for dvb_frontend_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// Check out the DiSEqC bus spec available on http://www.eutelsat.org/ for
/// the meaning of this struct...
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct dvb_diseqc_master_cmd {
    pub msg: [__u8; 6usize],
    pub msg_len: __u8,
}
#[test]
fn bindgen_test_layout_dvb_diseqc_master_cmd() {
    assert_eq!(::std::mem::size_of::<dvb_diseqc_master_cmd>() , 7usize ,
               concat ! ( "Size of: " , stringify ! ( dvb_diseqc_master_cmd )
               ));
    assert_eq! (::std::mem::align_of::<dvb_diseqc_master_cmd>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( dvb_diseqc_master_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_diseqc_master_cmd ) ) . msg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_diseqc_master_cmd )
                , "::" , stringify ! ( msg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_diseqc_master_cmd ) ) . msg_len as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_diseqc_master_cmd )
                , "::" , stringify ! ( msg_len ) ));
}
impl Clone for dvb_diseqc_master_cmd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct dvb_diseqc_slave_reply {
    pub msg: [__u8; 4usize],
    pub msg_len: __u8,
    pub timeout: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_dvb_diseqc_slave_reply() {
    assert_eq!(::std::mem::size_of::<dvb_diseqc_slave_reply>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( dvb_diseqc_slave_reply )
               ));
    assert_eq! (::std::mem::align_of::<dvb_diseqc_slave_reply>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( dvb_diseqc_slave_reply ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_diseqc_slave_reply ) ) . msg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_diseqc_slave_reply
                ) , "::" , stringify ! ( msg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_diseqc_slave_reply ) ) . msg_len as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_diseqc_slave_reply
                ) , "::" , stringify ! ( msg_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_diseqc_slave_reply ) ) . timeout as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_diseqc_slave_reply
                ) , "::" , stringify ! ( timeout ) ));
}
impl Clone for dvb_diseqc_slave_reply {
    fn clone(&self) -> Self { *self }
}
pub const SEC_VOLTAGE_13: fe_sec_voltage = 0;
pub const SEC_VOLTAGE_18: fe_sec_voltage = 1;
pub const SEC_VOLTAGE_OFF: fe_sec_voltage = 2;
pub type fe_sec_voltage = ::std::os::raw::c_uint;
pub const SEC_TONE_ON: fe_sec_tone_mode = 0;
pub const SEC_TONE_OFF: fe_sec_tone_mode = 1;
pub type fe_sec_tone_mode = ::std::os::raw::c_uint;
pub const SEC_MINI_A: fe_sec_mini_cmd = 0;
pub const SEC_MINI_B: fe_sec_mini_cmd = 1;
pub type fe_sec_mini_cmd = ::std::os::raw::c_uint;
pub const FE_HAS_SIGNAL: fe_status = 1;
pub const FE_HAS_CARRIER: fe_status = 2;
pub const FE_HAS_VITERBI: fe_status = 4;
pub const FE_HAS_SYNC: fe_status = 8;
pub const FE_HAS_LOCK: fe_status = 16;
pub const FE_TIMEDOUT: fe_status = 32;
pub const FE_REINIT: fe_status = 64;
/// enum fe_status - enumerates the possible frontend status
/// @FE_HAS_SIGNAL:	found something above the noise level
/// @FE_HAS_CARRIER:	found a DVB signal
/// @FE_HAS_VITERBI:	FEC is stable
/// @FE_HAS_SYNC:	found sync bytes
/// @FE_HAS_LOCK:	everything's working
/// @FE_TIMEDOUT:	no lock within the last ~2 seconds
/// @FE_REINIT:		frontend was reinitialized, application is recommended
/// to reset DiSEqC, tone and parameters
pub type fe_status = ::std::os::raw::c_uint;
pub const INVERSION_OFF: fe_spectral_inversion = 0;
pub const INVERSION_ON: fe_spectral_inversion = 1;
pub const INVERSION_AUTO: fe_spectral_inversion = 2;
pub type fe_spectral_inversion = ::std::os::raw::c_uint;
pub const FEC_NONE: fe_code_rate = 0;
pub const FEC_1_2: fe_code_rate = 1;
pub const FEC_2_3: fe_code_rate = 2;
pub const FEC_3_4: fe_code_rate = 3;
pub const FEC_4_5: fe_code_rate = 4;
pub const FEC_5_6: fe_code_rate = 5;
pub const FEC_6_7: fe_code_rate = 6;
pub const FEC_7_8: fe_code_rate = 7;
pub const FEC_8_9: fe_code_rate = 8;
pub const FEC_AUTO: fe_code_rate = 9;
pub const FEC_3_5: fe_code_rate = 10;
pub const FEC_9_10: fe_code_rate = 11;
pub const FEC_2_5: fe_code_rate = 12;
pub type fe_code_rate = ::std::os::raw::c_uint;
pub const QPSK: fe_modulation = 0;
pub const QAM_16: fe_modulation = 1;
pub const QAM_32: fe_modulation = 2;
pub const QAM_64: fe_modulation = 3;
pub const QAM_128: fe_modulation = 4;
pub const QAM_256: fe_modulation = 5;
pub const QAM_AUTO: fe_modulation = 6;
pub const VSB_8: fe_modulation = 7;
pub const VSB_16: fe_modulation = 8;
pub const PSK_8: fe_modulation = 9;
pub const APSK_16: fe_modulation = 10;
pub const APSK_32: fe_modulation = 11;
pub const DQPSK: fe_modulation = 12;
pub const QAM_4_NR: fe_modulation = 13;
pub type fe_modulation = ::std::os::raw::c_uint;
pub const TRANSMISSION_MODE_2K: fe_transmit_mode = 0;
pub const TRANSMISSION_MODE_8K: fe_transmit_mode = 1;
pub const TRANSMISSION_MODE_AUTO: fe_transmit_mode = 2;
pub const TRANSMISSION_MODE_4K: fe_transmit_mode = 3;
pub const TRANSMISSION_MODE_1K: fe_transmit_mode = 4;
pub const TRANSMISSION_MODE_16K: fe_transmit_mode = 5;
pub const TRANSMISSION_MODE_32K: fe_transmit_mode = 6;
pub const TRANSMISSION_MODE_C1: fe_transmit_mode = 7;
pub const TRANSMISSION_MODE_C3780: fe_transmit_mode = 8;
pub type fe_transmit_mode = ::std::os::raw::c_uint;
pub const GUARD_INTERVAL_1_32: fe_guard_interval = 0;
pub const GUARD_INTERVAL_1_16: fe_guard_interval = 1;
pub const GUARD_INTERVAL_1_8: fe_guard_interval = 2;
pub const GUARD_INTERVAL_1_4: fe_guard_interval = 3;
pub const GUARD_INTERVAL_AUTO: fe_guard_interval = 4;
pub const GUARD_INTERVAL_1_128: fe_guard_interval = 5;
pub const GUARD_INTERVAL_19_128: fe_guard_interval = 6;
pub const GUARD_INTERVAL_19_256: fe_guard_interval = 7;
pub const GUARD_INTERVAL_PN420: fe_guard_interval = 8;
pub const GUARD_INTERVAL_PN595: fe_guard_interval = 9;
pub const GUARD_INTERVAL_PN945: fe_guard_interval = 10;
pub type fe_guard_interval = ::std::os::raw::c_uint;
pub const HIERARCHY_NONE: fe_hierarchy = 0;
pub const HIERARCHY_1: fe_hierarchy = 1;
pub const HIERARCHY_2: fe_hierarchy = 2;
pub const HIERARCHY_4: fe_hierarchy = 3;
pub const HIERARCHY_AUTO: fe_hierarchy = 4;
pub type fe_hierarchy = ::std::os::raw::c_uint;
pub const INTERLEAVING_NONE: fe_interleaving = 0;
pub const INTERLEAVING_AUTO: fe_interleaving = 1;
pub const INTERLEAVING_240: fe_interleaving = 2;
pub const INTERLEAVING_720: fe_interleaving = 3;
pub type fe_interleaving = ::std::os::raw::c_uint;
pub const PILOT_ON: fe_pilot = 0;
pub const PILOT_OFF: fe_pilot = 1;
pub const PILOT_AUTO: fe_pilot = 2;
pub type fe_pilot = ::std::os::raw::c_uint;
pub const ROLLOFF_35: fe_rolloff = 0;
pub const ROLLOFF_20: fe_rolloff = 1;
pub const ROLLOFF_25: fe_rolloff = 2;
pub const ROLLOFF_AUTO: fe_rolloff = 3;
pub type fe_rolloff = ::std::os::raw::c_uint;
pub const SYS_UNDEFINED: fe_delivery_system = 0;
pub const SYS_DVBC_ANNEX_A: fe_delivery_system = 1;
pub const SYS_DVBC_ANNEX_B: fe_delivery_system = 2;
pub const SYS_DVBT: fe_delivery_system = 3;
pub const SYS_DSS: fe_delivery_system = 4;
pub const SYS_DVBS: fe_delivery_system = 5;
pub const SYS_DVBS2: fe_delivery_system = 6;
pub const SYS_DVBH: fe_delivery_system = 7;
pub const SYS_ISDBT: fe_delivery_system = 8;
pub const SYS_ISDBS: fe_delivery_system = 9;
pub const SYS_ISDBC: fe_delivery_system = 10;
pub const SYS_ATSC: fe_delivery_system = 11;
pub const SYS_ATSCMH: fe_delivery_system = 12;
pub const SYS_DTMB: fe_delivery_system = 13;
pub const SYS_CMMB: fe_delivery_system = 14;
pub const SYS_DAB: fe_delivery_system = 15;
pub const SYS_DVBT2: fe_delivery_system = 16;
pub const SYS_TURBO: fe_delivery_system = 17;
pub const SYS_DVBC_ANNEX_C: fe_delivery_system = 18;
pub type fe_delivery_system = ::std::os::raw::c_uint;
pub const ATSCMH_SCCC_BLK_SEP: atscmh_sccc_block_mode = 0;
pub const ATSCMH_SCCC_BLK_COMB: atscmh_sccc_block_mode = 1;
pub const ATSCMH_SCCC_BLK_RES: atscmh_sccc_block_mode = 2;
pub type atscmh_sccc_block_mode = ::std::os::raw::c_uint;
pub const ATSCMH_SCCC_CODE_HLF: atscmh_sccc_code_mode = 0;
pub const ATSCMH_SCCC_CODE_QTR: atscmh_sccc_code_mode = 1;
pub const ATSCMH_SCCC_CODE_RES: atscmh_sccc_code_mode = 2;
pub type atscmh_sccc_code_mode = ::std::os::raw::c_uint;
pub const ATSCMH_RSFRAME_ENS_PRI: atscmh_rs_frame_ensemble = 0;
pub const ATSCMH_RSFRAME_ENS_SEC: atscmh_rs_frame_ensemble = 1;
pub type atscmh_rs_frame_ensemble = ::std::os::raw::c_uint;
pub const ATSCMH_RSFRAME_PRI_ONLY: atscmh_rs_frame_mode = 0;
pub const ATSCMH_RSFRAME_PRI_SEC: atscmh_rs_frame_mode = 1;
pub const ATSCMH_RSFRAME_RES: atscmh_rs_frame_mode = 2;
pub type atscmh_rs_frame_mode = ::std::os::raw::c_uint;
pub const ATSCMH_RSCODE_211_187: atscmh_rs_code_mode = 0;
pub const ATSCMH_RSCODE_223_187: atscmh_rs_code_mode = 1;
pub const ATSCMH_RSCODE_235_187: atscmh_rs_code_mode = 2;
pub const ATSCMH_RSCODE_RES: atscmh_rs_code_mode = 3;
pub type atscmh_rs_code_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dtv_cmds_h {
    pub name: *mut ::std::os::raw::c_char,
    pub cmd: __u32,
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_dtv_cmds_h() {
    assert_eq!(::std::mem::size_of::<dtv_cmds_h>() , 16usize , concat ! (
               "Size of: " , stringify ! ( dtv_cmds_h ) ));
    assert_eq! (::std::mem::align_of::<dtv_cmds_h>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dtv_cmds_h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_cmds_h ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_cmds_h ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_cmds_h ) ) . cmd as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_cmds_h ) , "::" ,
                stringify ! ( cmd ) ));
}
impl Clone for dtv_cmds_h {
    fn clone(&self) -> Self { *self }
}
impl Default for dtv_cmds_h {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl dtv_cmds_h {
    #[inline]
    pub fn set(&self) -> __u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 1u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_set(&mut self, val: __u32) {
        let mask = 1u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn buffer(&self) -> __u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 2u64 as u32;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_buffer(&mut self, val: __u32) {
        let mask = 2u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> __u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967292u64 as u32;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        let mask = 4294967292u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(set: __u32, buffer: __u32, reserved: __u32) -> u32 {
        ({
             ({ ({ 0 } | ((set as u32 as u32) << 0usize) & (1u64 as u32)) } |
                  ((buffer as u32 as u32) << 1usize) & (2u64 as u32))
         } | ((reserved as u32 as u32) << 2usize) & (4294967292u64 as u32))
    }
}
pub const FE_SCALE_NOT_AVAILABLE: fecap_scale_params = 0;
pub const FE_SCALE_DECIBEL: fecap_scale_params = 1;
pub const FE_SCALE_RELATIVE: fecap_scale_params = 2;
pub const FE_SCALE_COUNTER: fecap_scale_params = 3;
/// Scale types for the quality parameters.
/// @FE_SCALE_NOT_AVAILABLE: That QoS measure is not available. That
/// could indicate a temporary or a permanent
/// condition.
/// @FE_SCALE_DECIBEL: The scale is measured in 0.001 dB steps, typically
/// used on signal measures.
/// @FE_SCALE_RELATIVE: The scale is a relative percentual measure,
/// ranging from 0 (0%) to 0xffff (100%).
/// @FE_SCALE_COUNTER: The scale counts the occurrence of an event, like
/// bit error, block error, lapsed time.
pub type fecap_scale_params = ::std::os::raw::c_uint;
/// struct dtv_stats - Used for reading a DTV status property
///
/// @value:	value of the measure. Should range from 0 to 0xffff;
/// @scale:	Filled with enum fecap_scale_params - the scale
/// in usage for that parameter
///
/// For most delivery systems, this will return a single value for each
/// parameter.
/// It should be noticed, however, that new OFDM delivery systems like
/// ISDB can use different modulation types for each group of carriers.
/// On such standards, up to 8 groups of statistics can be provided, one
/// for each carrier group (called "layer" on ISDB).
/// In order to be consistent with other delivery systems, the first
/// value refers to the entire set of carriers ("global").
/// dtv_status:scale should use the value FE_SCALE_NOT_AVAILABLE when
/// the value for the entire group of carriers or from one specific layer
/// is not provided by the hardware.
/// st.len should be filled with the latest filled status + 1.
///
/// In other words, for ISDB, those values should be filled like:
/// u.st.stat.svalue[0] = global statistics;
/// u.st.stat.scale[0] = FE_SCALE_DECIBEL;
/// u.st.stat.value[1] = layer A statistics;
/// u.st.stat.scale[1] = FE_SCALE_NOT_AVAILABLE (if not available);
/// u.st.stat.svalue[2] = layer B statistics;
/// u.st.stat.scale[2] = FE_SCALE_DECIBEL;
/// u.st.stat.svalue[3] = layer C statistics;
/// u.st.stat.scale[3] = FE_SCALE_DECIBEL;
/// u.st.len = 4;
#[repr(C, packed)]
#[derive(Copy)]
pub struct dtv_stats {
    pub scale: __u8,
    pub __bindgen_anon_1: dtv_stats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union dtv_stats__bindgen_ty_1 {
    pub uvalue: __u64,
    pub svalue: __s64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_dtv_stats__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<dtv_stats__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( dtv_stats__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<dtv_stats__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( dtv_stats__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_stats__bindgen_ty_1 ) ) . uvalue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_stats__bindgen_ty_1
                ) , "::" , stringify ! ( uvalue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_stats__bindgen_ty_1 ) ) . svalue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_stats__bindgen_ty_1
                ) , "::" , stringify ! ( svalue ) ));
}
impl Clone for dtv_stats__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for dtv_stats__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_dtv_stats() {
    assert_eq!(::std::mem::size_of::<dtv_stats>() , 9usize , concat ! (
               "Size of: " , stringify ! ( dtv_stats ) ));
    assert_eq! (::std::mem::align_of::<dtv_stats>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( dtv_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_stats ) ) . scale as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_stats ) , "::" ,
                stringify ! ( scale ) ));
}
impl Clone for dtv_stats {
    fn clone(&self) -> Self { *self }
}
impl Default for dtv_stats {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct dtv_fe_stats {
    pub len: __u8,
    pub stat: [dtv_stats; 4usize],
}
#[test]
fn bindgen_test_layout_dtv_fe_stats() {
    assert_eq!(::std::mem::size_of::<dtv_fe_stats>() , 37usize , concat ! (
               "Size of: " , stringify ! ( dtv_fe_stats ) ));
    assert_eq! (::std::mem::align_of::<dtv_fe_stats>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( dtv_fe_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_fe_stats ) ) . len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_fe_stats ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_fe_stats ) ) . stat as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_fe_stats ) , "::" ,
                stringify ! ( stat ) ));
}
impl Clone for dtv_fe_stats {
    fn clone(&self) -> Self { *self }
}
impl Default for dtv_fe_stats {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct dtv_property {
    pub cmd: __u32,
    pub reserved: [__u32; 3usize],
    pub u: dtv_property__bindgen_ty_1,
    pub result: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy)]
pub union dtv_property__bindgen_ty_1 {
    pub data: __u32,
    pub st: dtv_fe_stats,
    pub buffer: dtv_property__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dtv_property__bindgen_ty_1__bindgen_ty_1 {
    pub data: [__u8; 32usize],
    pub len: __u32,
    pub reserved1: [__u32; 3usize],
    pub reserved2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_dtv_property__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<dtv_property__bindgen_ty_1__bindgen_ty_1>()
               , 56usize , concat ! (
               "Size of: " , stringify ! (
               dtv_property__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<dtv_property__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                dtv_property__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const dtv_property__bindgen_ty_1__bindgen_ty_1 ) )
                . data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dtv_property__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( data ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const dtv_property__bindgen_ty_1__bindgen_ty_1 ) )
                . len as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                dtv_property__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( len ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const dtv_property__bindgen_ty_1__bindgen_ty_1 ) )
                . reserved1 as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                dtv_property__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const dtv_property__bindgen_ty_1__bindgen_ty_1 ) )
                . reserved2 as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                dtv_property__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( reserved2 ) ));
}
impl Clone for dtv_property__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for dtv_property__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_dtv_property__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<dtv_property__bindgen_ty_1>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( dtv_property__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<dtv_property__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( dtv_property__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_property__bindgen_ty_1 ) ) . data as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dtv_property__bindgen_ty_1 ) , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_property__bindgen_ty_1 ) ) . st as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dtv_property__bindgen_ty_1 ) , "::" , stringify ! ( st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_property__bindgen_ty_1 ) ) . buffer
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dtv_property__bindgen_ty_1 ) , "::" , stringify ! ( buffer )
                ));
}
impl Clone for dtv_property__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for dtv_property__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_dtv_property() {
    assert_eq!(::std::mem::size_of::<dtv_property>() , 76usize , concat ! (
               "Size of: " , stringify ! ( dtv_property ) ));
    assert_eq! (::std::mem::align_of::<dtv_property>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( dtv_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_property ) ) . cmd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_property ) , "::" ,
                stringify ! ( cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_property ) ) . reserved as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_property ) , "::" ,
                stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_property ) ) . u as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_property ) , "::" ,
                stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_property ) ) . result as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_property ) , "::" ,
                stringify ! ( result ) ));
}
impl Clone for dtv_property {
    fn clone(&self) -> Self { *self }
}
impl Default for dtv_property {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dtv_properties {
    pub num: __u32,
    pub props: *mut dtv_property,
}
#[test]
fn bindgen_test_layout_dtv_properties() {
    assert_eq!(::std::mem::size_of::<dtv_properties>() , 16usize , concat ! (
               "Size of: " , stringify ! ( dtv_properties ) ));
    assert_eq! (::std::mem::align_of::<dtv_properties>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dtv_properties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_properties ) ) . num as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_properties ) , "::"
                , stringify ! ( num ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dtv_properties ) ) . props as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dtv_properties ) , "::"
                , stringify ! ( props ) ));
}
impl Clone for dtv_properties {
    fn clone(&self) -> Self { *self }
}
impl Default for dtv_properties {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub const BANDWIDTH_8_MHZ: fe_bandwidth = 0;
pub const BANDWIDTH_7_MHZ: fe_bandwidth = 1;
pub const BANDWIDTH_6_MHZ: fe_bandwidth = 2;
pub const BANDWIDTH_AUTO: fe_bandwidth = 3;
pub const BANDWIDTH_5_MHZ: fe_bandwidth = 4;
pub const BANDWIDTH_10_MHZ: fe_bandwidth = 5;
pub const BANDWIDTH_1_712_MHZ: fe_bandwidth = 6;
pub type fe_bandwidth = ::std::os::raw::c_uint;
pub use self::fe_sec_voltage as fe_sec_voltage_t;
pub use self::fe_caps as fe_caps_t;
pub use self::fe_type as fe_type_t;
pub use self::fe_sec_tone_mode as fe_sec_tone_mode_t;
pub use self::fe_sec_mini_cmd as fe_sec_mini_cmd_t;
pub use self::fe_status as fe_status_t;
pub use self::fe_spectral_inversion as fe_spectral_inversion_t;
pub use self::fe_code_rate as fe_code_rate_t;
pub use self::fe_modulation as fe_modulation_t;
pub use self::fe_transmit_mode as fe_transmit_mode_t;
pub use self::fe_bandwidth as fe_bandwidth_t;
pub use self::fe_guard_interval as fe_guard_interval_t;
pub use self::fe_hierarchy as fe_hierarchy_t;
pub use self::fe_pilot as fe_pilot_t;
pub use self::fe_rolloff as fe_rolloff_t;
pub use self::fe_delivery_system as fe_delivery_system_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dvb_qpsk_parameters {
    pub symbol_rate: __u32,
    pub fec_inner: fe_code_rate_t,
}
#[test]
fn bindgen_test_layout_dvb_qpsk_parameters() {
    assert_eq!(::std::mem::size_of::<dvb_qpsk_parameters>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( dvb_qpsk_parameters ) ));
    assert_eq! (::std::mem::align_of::<dvb_qpsk_parameters>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( dvb_qpsk_parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_qpsk_parameters ) ) . symbol_rate as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_qpsk_parameters ) ,
                "::" , stringify ! ( symbol_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_qpsk_parameters ) ) . fec_inner as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_qpsk_parameters ) ,
                "::" , stringify ! ( fec_inner ) ));
}
impl Clone for dvb_qpsk_parameters {
    fn clone(&self) -> Self { *self }
}
impl Default for dvb_qpsk_parameters {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dvb_qam_parameters {
    pub symbol_rate: __u32,
    pub fec_inner: fe_code_rate_t,
    pub modulation: fe_modulation_t,
}
#[test]
fn bindgen_test_layout_dvb_qam_parameters() {
    assert_eq!(::std::mem::size_of::<dvb_qam_parameters>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( dvb_qam_parameters ) ));
    assert_eq! (::std::mem::align_of::<dvb_qam_parameters>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( dvb_qam_parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_qam_parameters ) ) . symbol_rate as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_qam_parameters ) ,
                "::" , stringify ! ( symbol_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_qam_parameters ) ) . fec_inner as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_qam_parameters ) ,
                "::" , stringify ! ( fec_inner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_qam_parameters ) ) . modulation as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_qam_parameters ) ,
                "::" , stringify ! ( modulation ) ));
}
impl Clone for dvb_qam_parameters {
    fn clone(&self) -> Self { *self }
}
impl Default for dvb_qam_parameters {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dvb_vsb_parameters {
    pub modulation: fe_modulation_t,
}
#[test]
fn bindgen_test_layout_dvb_vsb_parameters() {
    assert_eq!(::std::mem::size_of::<dvb_vsb_parameters>() , 4usize , concat !
               ( "Size of: " , stringify ! ( dvb_vsb_parameters ) ));
    assert_eq! (::std::mem::align_of::<dvb_vsb_parameters>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( dvb_vsb_parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_vsb_parameters ) ) . modulation as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_vsb_parameters ) ,
                "::" , stringify ! ( modulation ) ));
}
impl Clone for dvb_vsb_parameters {
    fn clone(&self) -> Self { *self }
}
impl Default for dvb_vsb_parameters {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dvb_ofdm_parameters {
    pub bandwidth: fe_bandwidth_t,
    pub code_rate_HP: fe_code_rate_t,
    pub code_rate_LP: fe_code_rate_t,
    pub constellation: fe_modulation_t,
    pub transmission_mode: fe_transmit_mode_t,
    pub guard_interval: fe_guard_interval_t,
    pub hierarchy_information: fe_hierarchy_t,
}
#[test]
fn bindgen_test_layout_dvb_ofdm_parameters() {
    assert_eq!(::std::mem::size_of::<dvb_ofdm_parameters>() , 28usize , concat
               ! ( "Size of: " , stringify ! ( dvb_ofdm_parameters ) ));
    assert_eq! (::std::mem::align_of::<dvb_ofdm_parameters>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( dvb_ofdm_parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_ofdm_parameters ) ) . bandwidth as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_ofdm_parameters ) ,
                "::" , stringify ! ( bandwidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_ofdm_parameters ) ) . code_rate_HP as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_ofdm_parameters ) ,
                "::" , stringify ! ( code_rate_HP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_ofdm_parameters ) ) . code_rate_LP as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_ofdm_parameters ) ,
                "::" , stringify ! ( code_rate_LP ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_ofdm_parameters ) ) . constellation
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_ofdm_parameters ) ,
                "::" , stringify ! ( constellation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_ofdm_parameters ) ) .
                transmission_mode as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( dvb_ofdm_parameters ) ,
                "::" , stringify ! ( transmission_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_ofdm_parameters ) ) . guard_interval
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_ofdm_parameters ) ,
                "::" , stringify ! ( guard_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_ofdm_parameters ) ) .
                hierarchy_information as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( dvb_ofdm_parameters ) ,
                "::" , stringify ! ( hierarchy_information ) ));
}
impl Clone for dvb_ofdm_parameters {
    fn clone(&self) -> Self { *self }
}
impl Default for dvb_ofdm_parameters {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct dvb_frontend_parameters {
    pub frequency: __u32,
    pub inversion: fe_spectral_inversion_t,
    pub u: dvb_frontend_parameters__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union dvb_frontend_parameters__bindgen_ty_1 {
    pub qpsk: dvb_qpsk_parameters,
    pub qam: dvb_qam_parameters,
    pub ofdm: dvb_ofdm_parameters,
    pub vsb: dvb_vsb_parameters,
    _bindgen_union_align: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_dvb_frontend_parameters__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<dvb_frontend_parameters__bindgen_ty_1>()
               , 28usize , concat ! (
               "Size of: " , stringify ! (
               dvb_frontend_parameters__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<dvb_frontend_parameters__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                dvb_frontend_parameters__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_parameters__bindgen_ty_1 ) )
                . qpsk as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dvb_frontend_parameters__bindgen_ty_1 ) , "::" , stringify ! (
                qpsk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_parameters__bindgen_ty_1 ) )
                . qam as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dvb_frontend_parameters__bindgen_ty_1 ) , "::" , stringify ! (
                qam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_parameters__bindgen_ty_1 ) )
                . ofdm as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dvb_frontend_parameters__bindgen_ty_1 ) , "::" , stringify ! (
                ofdm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_parameters__bindgen_ty_1 ) )
                . vsb as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                dvb_frontend_parameters__bindgen_ty_1 ) , "::" , stringify ! (
                vsb ) ));
}
impl Clone for dvb_frontend_parameters__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for dvb_frontend_parameters__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_dvb_frontend_parameters() {
    assert_eq!(::std::mem::size_of::<dvb_frontend_parameters>() , 36usize ,
               concat ! (
               "Size of: " , stringify ! ( dvb_frontend_parameters ) ));
    assert_eq! (::std::mem::align_of::<dvb_frontend_parameters>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( dvb_frontend_parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_parameters ) ) . frequency
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_parameters
                ) , "::" , stringify ! ( frequency ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_parameters ) ) . inversion
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_parameters
                ) , "::" , stringify ! ( inversion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_parameters ) ) . u as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_parameters
                ) , "::" , stringify ! ( u ) ));
}
impl Clone for dvb_frontend_parameters {
    fn clone(&self) -> Self { *self }
}
impl Default for dvb_frontend_parameters {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct dvb_frontend_event {
    pub status: fe_status_t,
    pub parameters: dvb_frontend_parameters,
}
#[test]
fn bindgen_test_layout_dvb_frontend_event() {
    assert_eq!(::std::mem::size_of::<dvb_frontend_event>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( dvb_frontend_event ) ));
    assert_eq! (::std::mem::align_of::<dvb_frontend_event>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( dvb_frontend_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_event ) ) . status as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_event ) ,
                "::" , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dvb_frontend_event ) ) . parameters as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( dvb_frontend_event ) ,
                "::" , stringify ! ( parameters ) ));
}
impl Clone for dvb_frontend_event {
    fn clone(&self) -> Self { *self }
}
impl Default for dvb_frontend_event {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
